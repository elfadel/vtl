diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/certs/signing_key.pem linux-stable/certs/signing_key.pem
--- linux-5-3-5/certs/signing_key.pem	1970-01-01 01:00:00.000000000 +0100
+++ linux-stable/certs/signing_key.pem	2019-12-23 07:36:33.871803181 +0100
@@ -0,0 +1,83 @@
+-----BEGIN PRIVATE KEY-----
+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
+g4M/LbIVBRAha4V07iB7GjNqPxmEqw==
+-----END PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIFSTCCAzGgAwIBAgIUATUR691gh2yYaX4W+3qrykUCCigwDQYJKoZIhvcNAQEN
+BQAwLjEsMCoGA1UEAwwjQnVpbGQgdGltZSBhdXRvZ2VuZXJhdGVkIGtlcm5lbCBr
+ZXkwIBcNMTkxMjIzMDYzNjMzWhgPMjExOTExMjkwNjM2MzNaMC4xLDAqBgNVBAMM
+I0J1aWxkIHRpbWUgYXV0b2dlbmVyYXRlZCBrZXJuZWwga2V5MIICIjANBgkqhkiG
+9w0BAQEFAAOCAg8AMIICCgKCAgEA4ELTi2KRrxXzpIskkjIL5DxaneGDD8uf4lP6
+tUGZ82oBKR/AHfQLFcPfso3fsP5ZXzBsOIwRlpzVjqo0oGIvrPEN/pKiMVVAPl43
+IQwvRc02U+OfZ0az+OJzHXz5/k4JCAGRBV+nLFSEhqu9jqR9v/Vbj4SyDgTiYEQz
+QJJ84tUyWL1sTfSbj5pJbcMaBGKGN3CZJeDTQCOExBAE3cSoQHb6rUDboSe8x3/L
+0OiUHAIRLjdyzGqIz/fN75kCBR8I/x4gOjLHgwZvNjJHfi/ybq+ZnJxFDZ5mcM9J
+I1kNQSEM7SPeFcTV78JB70nSiK3qkY03SZrS664IkNKbr0XZWF0zd6gE2GFOD3E2
+kbjIC/rPYvEqfvHewfWHlK+gU2FzqYYlMQXTIxtU0rpfpL/hVud3eAvLm/772W/1
+LBaU2C/T+rPAwiWv1+8NzSDLCgA1kekLa9/tsFIJsd4fKMNgtmIurV65YrPbuTYo
+/4jiADPwHRlwFqDe0J8JuWKgEXtQxd2HY3Fs/fZPdZijkFIBcff6p2VF73UhdDDF
+grp1PAeeVjg4QmF7ntXVg+T2ll7zFWbUSn4B9gPadRDK5L/snZLs1TN+B8b7K36S
+GgkjwP97RqJ33bsKt5mconVXgsEAlgcGBSu893L1hGTsAmkodTgZv/96xcFgEVdr
+eSkYOl8CAwEAAaNdMFswDAYDVR0TAQH/BAIwADALBgNVHQ8EBAMCB4AwHQYDVR0O
+BBYEFCsHJCJNdYMQj4EGBUuO4zICj5xVMB8GA1UdIwQYMBaAFCsHJCJNdYMQj4EG
+BUuO4zICj5xVMA0GCSqGSIb3DQEBDQUAA4ICAQBl06DKNsxM+bHr+g2wfVZnj+p8
+Yn/i1ETF65zwpO1bvwSgKUyrsAypSx0Cw+VvGAyWXU0FYMxXg5nNspF4CSmJoeSw
+FJaDJCPdGM8acsXRN121RdJDkLYaftjqtUcbxdM6/EhffP6/9MOL8ebt58vZGjGR
+TLY31r7Ty+ew2HSR/IQrUTiCFtGPmtqvqCiQ/n51ZFS+NKZxdcPYPscgzyJWlP/Y
+j++ZV2DUiBlKHiCCZ1uKYN/Hd93V9pA8CCQWWUvknufDhAm+fK/K5iLlqPbbpvSe
+BvdRbzBZwvAC74q30q61FTsj784F8gxBC0c7uCcuWjnri50FeBhA8fkgZ3AScCII
+wihvyQffO4W1TiUltSsHw6vMSnehTV38CN46NN8ZgTsVROOs/9UcDzIIb+Z+2+hO
+1g0XTrtoV+ZjHoIBaGOUdBPt99zWo+/15+c2dwZL7xtUdWlX6l0e37PSbjYgb7Z2
+AQ0H06U7r519DXUhifee0/+r7luZ9n1UTkGavUvfARBS/pSljzdI5DdhHLw75NEu
+7FDBoYOmwTDCyzFUpYssmuntoh7MEPp/4oheHfR2vUTfW11v88ChP1mZCc3ZbXEY
+rbjRN9S1BS9/QaQ4F1D4YgfpXVHJUieJaoc0qqgDLRGs02o4H8DmARD316oBMoiy
+ms5dtEJS0HXhqiLi9Q==
+-----END CERTIFICATE-----
Binary files linux-5-3-5/certs/signing_key.x509 and linux-stable/certs/signing_key.x509 differ
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/certs/x509.genkey linux-stable/certs/x509.genkey
--- linux-5-3-5/certs/x509.genkey	1970-01-01 01:00:00.000000000 +0100
+++ linux-stable/certs/x509.genkey	2019-12-23 07:36:32.907321180 +0100
@@ -0,0 +1,17 @@
+[ req ]
+default_bits = 4096
+distinguished_name = req_distinguished_name
+prompt = no
+string_mask = utf8only
+x509_extensions = myexts
+
+[ req_distinguished_name ]
+#O = Unspecified company
+CN = Build time autogenerated kernel key
+#emailAddress = unspecified.user@unspecified.company
+
+[ myexts ]
+basicConstraints=critical,CA:FALSE
+keyUsage=digitalSignature
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/include/net/request_sock.h linux-stable/include/net/request_sock.h
--- linux-5-3-5/include/net/request_sock.h	2021-11-15 14:40:25.095490027 +0100
+++ linux-stable/include/net/request_sock.h	2020-07-06 09:50:12.986566693 +0200
@@ -61,6 +61,7 @@ struct request_sock {
 	const struct request_sock_ops	*rsk_ops;
 	struct sock			*sk;
 	u32				*saved_syn;
+	//u32 			*saved_syn_ack;
 	u32				secid;
 	u32				peer_secid;
 };
@@ -97,6 +98,7 @@ reqsk_alloc(const struct request_sock_op
 	sk_node_init(&req_to_sk(req)->sk_node);
 	sk_tx_queue_clear(req_to_sk(req));
 	req->saved_syn = NULL;
+	//req->saved_syn_ack = NULL;
 	req->num_timeout = 0;
 	req->num_retrans = 0;
 	req->sk = NULL;
@@ -111,6 +113,7 @@ static inline void __reqsk_free(struct r
 	if (req->rsk_listener)
 		sock_put(req->rsk_listener);
 	kfree(req->saved_syn);
+	//kfree(req->saved_syn_ack);
 	kmem_cache_free(req->rsk_ops->slab, req);
 }
 
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/include/net/tcp.h linux-stable/include/net/tcp.h
--- linux-5-3-5/include/net/tcp.h	2021-11-15 14:40:25.095490027 +0100
+++ linux-stable/include/net/tcp.h	2020-07-10 22:21:09.249086868 +0200
@@ -570,6 +570,7 @@ int tcp_send_synack(struct sock *);
 void tcp_push_one(struct sock *, unsigned int mss_now);
 void __tcp_send_ack(struct sock *sk, u32 rcv_nxt);
 void tcp_send_ack(struct sock *sk);
+void vtl_tcp_send_ack(struct sock *sk);
 void tcp_send_delayed_ack(struct sock *sk);
 void tcp_send_loss_probe(struct sock *sk);
 bool tcp_schedule_loss_probe(struct sock *sk, bool advancing_rto);
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/kernel/bpf/core.c linux-stable/kernel/bpf/core.c
--- linux-5-3-5/kernel/bpf/core.c	2021-11-15 14:40:25.227424032 +0100
+++ linux-stable/kernel/bpf/core.c	2020-02-15 15:49:44.179087097 +0100
@@ -2036,6 +2036,8 @@ const struct bpf_func_proto bpf_get_pran
 const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;
 const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;
 const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;
+//const struct bpf_func_proto bpf_vtl_nic_tx_proto __weak;
+const struct bpf_func_proto bpf_vtl_start_timer_proto __weak;
 
 const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;
 const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/kernel/bpf/helpers.c linux-stable/kernel/bpf/helpers.c
--- linux-5-3-5/kernel/bpf/helpers.c	2021-11-15 14:40:25.227424032 +0100
+++ linux-stable/kernel/bpf/helpers.c	2020-01-14 18:26:19.868873517 +0100
@@ -11,6 +11,7 @@
 #include <linux/uidgid.h>
 #include <linux/filter.h>
 #include <linux/ctype.h>
+#include <linux/delay.h>
 
 #include "../../lib/kstrtox.h"
 
@@ -152,6 +153,17 @@ const struct bpf_func_proto bpf_ktime_ge
 	.ret_type	= RET_INTEGER,
 };
 
+BPF_CALL_1(bpf_vtl_start_timer, unsigned long long, vtl_timer) {
+	msleep(vtl_timer); //mdelay(vtl_timer);
+}
+
+const struct bpf_func_proto bpf_vtl_start_timer_proto = {
+	.func 			= bpf_vtl_start_timer,
+	.gpl_only 	= true,
+	.ret_type 	= RET_VOID,
+	.arg1_type 	= ARG_ANYTHING,
+};
+
 BPF_CALL_0(bpf_get_current_pid_tgid)
 {
 	struct task_struct *task = current;
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/net/core/filter.c linux-stable/net/core/filter.c
--- linux-5-3-5/net/core/filter.c	2021-11-15 14:40:26.170952064 +0100
+++ linux-stable/net/core/filter.c	2020-09-24 20:06:47.185574384 +0200
@@ -29,6 +29,7 @@
 #include <linux/if_packet.h>
 #include <linux/if_arp.h>
 #include <linux/gfp.h>
+#include <linux/delay.h>
 #include <net/inet_common.h>
 #include <net/ip.h>
 #include <net/protocol.h>
@@ -1698,6 +1699,46 @@ static const struct bpf_func_proto bpf_s
 	.arg5_type	= ARG_ANYTHING,
 };
 
+BPF_CALL_5(bpf_vtl_store_bytes, struct sk_buff *, skb, u32, offset,
+	   const void *, from, u32, len, u64, flags)
+{
+	void *ptr;
+
+	if(len > 0xffff)
+		return -EINVAL;
+
+	if (unlikely(flags & ~(BPF_F_RECOMPUTE_CSUM | BPF_F_INVALIDATE_HASH)))
+		return -EINVAL;
+	if (unlikely(offset > 0xffff))
+		return -EFAULT;
+	if (unlikely(bpf_try_make_writable(skb, offset + len)))
+		return -EFAULT;
+
+	ptr = skb->data + offset;
+	if (flags & BPF_F_RECOMPUTE_CSUM)
+		__skb_postpull_rcsum(skb, ptr, len, offset);
+
+	memcpy(ptr, from, len);
+
+	if (flags & BPF_F_RECOMPUTE_CSUM)
+		__skb_postpush_rcsum(skb, ptr, len, offset);
+	if (flags & BPF_F_INVALIDATE_HASH)
+		skb_clear_hash(skb);
+
+	return 0;
+}
+
+static const struct bpf_func_proto bpf_vtl_store_bytes_proto = {
+	.func		= bpf_vtl_store_bytes,
+	.gpl_only	= false,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_CTX,
+	.arg2_type	= ARG_ANYTHING,
+	.arg3_type	= ARG_PTR_TO_MEM,
+	.arg4_type	= ARG_CONST_SIZE,
+	.arg5_type	= ARG_ANYTHING,
+};
+
 BPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset,
 	   void *, to, u32, len)
 {
@@ -2108,6 +2149,45 @@ static int __bpf_redirect(struct sk_buff
 		return __bpf_redirect_no_mac(skb, dev, flags);
 }
 
+BPF_CALL_4(bpf_vtl_nic_tx, struct sk_buff *, skb, u32, ifindex,
+						unsigned long long, wait_time, u64, flags) {
+	struct net_device *dev;
+	struct sk_buff* clone;
+	int ret;
+
+	if(unlikely(flags & ~(BPF_F_INGRESS)))
+		return -EINVAL;
+
+	dev = dev_get_by_index_rcu(dev_net(skb->dev), ifindex);
+	if(unlikely(!dev)){
+		//kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	clone = skb_clone(skb, GFP_KERNEL); //may be GFP_ATOMIC
+	if(unlikely(!clone))
+		return -ENOMEM;
+
+	ret = bpf_try_make_head_writable(skb);
+	if(unlikely(ret)) {
+		kfree_skb(clone);
+		return -ENOMEM;
+	}
+
+	mdelay(wait_time);
+	return __bpf_redirect(clone, dev, flags);
+}
+
+static const struct bpf_func_proto bpf_vtl_nic_tx_proto = {
+	.func 			= bpf_vtl_nic_tx,
+	.gpl_only 	= false,
+	.ret_type 	= RET_INTEGER,
+	.arg1_type 	= ARG_PTR_TO_CTX,
+	.arg2_type 	= ARG_ANYTHING,
+	.arg3_type 	= ARG_ANYTHING,
+	.arg4_type 	= ARG_ANYTHING,
+};
+
 BPF_CALL_3(bpf_clone_redirect, struct sk_buff *, skb, u32, ifindex, u64, flags)
 {
 	struct net_device *dev;
@@ -4365,6 +4445,15 @@ BPF_CALL_5(bpf_setsockopt, struct bpf_so
 				else
 					tp->save_syn = val;
 				break;
+			/*case TCP_SAVE_SYN_ACK:
+				if(val < 0 || val > 1) {
+					ret = -EINVAL;
+				}
+				else {
+					tp->save_syn_ack = val;
+				}
+				break;
+			*/
 			default:
 				ret = -EINVAL;
 			}
@@ -4416,6 +4505,16 @@ BPF_CALL_5(bpf_getsockopt, struct bpf_so
 				goto err_clear;
 			memcpy(optval, tp->saved_syn + 1, optlen);
 			break;
+		/*case TCP_SAVED_SYN_ACK:
+			tp = tcp_sk(sk);
+
+			if(optlen <= 0 || !tp->saved_syn_ack ||
+			   optlen > tp->saved_syn_ack[0]) {
+				goto err_clear; 
+			}
+			memcpy(optval, tp->saved_syn_ack + 1, optlen);
+			break;
+		*/
 		default:
 			goto err_clear;
 		}
@@ -5857,6 +5956,7 @@ bool bpf_helper_changes_pkt_data(void *f
 	if (func == bpf_skb_vlan_push ||
 	    func == bpf_skb_vlan_pop ||
 	    func == bpf_skb_store_bytes ||
+	    func == bpf_vtl_store_bytes ||
 	    func == bpf_skb_change_proto ||
 	    func == bpf_skb_change_head ||
 	    func == sk_skb_change_head ||
@@ -5865,6 +5965,7 @@ bool bpf_helper_changes_pkt_data(void *f
 	    func == bpf_skb_adjust_room ||
 	    func == bpf_skb_pull_data ||
 	    func == sk_skb_pull_data ||
+	    func == bpf_vtl_nic_tx ||
 	    func == bpf_clone_redirect ||
 	    func == bpf_l3_csum_replace ||
 	    func == bpf_l4_csum_replace ||
@@ -5912,6 +6013,8 @@ bpf_base_func_proto(enum bpf_func_id fun
 		return &bpf_tail_call_proto;
 	case BPF_FUNC_ktime_get_ns:
 		return &bpf_ktime_get_ns_proto;
+	case BPF_FUNC_vtl_start_timer:
+		return &bpf_vtl_start_timer_proto;
 	default:
 		break;
 	}
@@ -6042,6 +6145,8 @@ tc_cls_act_func_proto(enum bpf_func_id f
 	switch (func_id) {
 	case BPF_FUNC_skb_store_bytes:
 		return &bpf_skb_store_bytes_proto;
+	case BPF_FUNC_vtl_store_bytes:
+		return &bpf_vtl_store_bytes_proto;
 	case BPF_FUNC_skb_load_bytes:
 		return &bpf_skb_load_bytes_proto;
 	case BPF_FUNC_skb_load_bytes_relative:
@@ -6056,6 +6161,8 @@ tc_cls_act_func_proto(enum bpf_func_id f
 		return &bpf_l3_csum_replace_proto;
 	case BPF_FUNC_l4_csum_replace:
 		return &bpf_l4_csum_replace_proto;
+	case BPF_FUNC_vtl_nic_tx:
+		return &bpf_vtl_nic_tx_proto;
 	case BPF_FUNC_clone_redirect:
 		return &bpf_clone_redirect_proto;
 	case BPF_FUNC_get_cgroup_classid:
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/net/ipv4/tcp.c linux-stable/net/ipv4/tcp.c
--- linux-5-3-5/net/ipv4/tcp.c	2021-11-15 14:40:26.354860072 +0100
+++ linux-stable/net/ipv4/tcp.c	2020-07-06 09:55:10.255141840 +0200
@@ -2625,6 +2625,7 @@ int tcp_disconnect(struct sock *sk, int
 	dst_release(sk->sk_rx_dst);
 	sk->sk_rx_dst = NULL;
 	tcp_saved_syn_free(tp);
+	//tcp_saved_syn_ack_free(tp);
 	tp->compressed_ack = 0;
 	tp->bytes_sent = 0;
 	tp->bytes_acked = 0;
@@ -3011,6 +3012,17 @@ static int do_tcp_setsockopt(struct sock
 			tp->save_syn = val;
 		break;
 
+	/*case TCP_SAVE_SYN_ACK:
+		if(val < 0 || val > 1) {
+			pr_warning("[TCP.c]: Cant' save SYN/ACK.\n");
+			err = -EINVAL;
+		}
+		else {
+			pr_warning("[TCP.c]: SYN/ACK saved.\n");
+			tp->save_syn_ack = val;
+		}
+		break;
+	*/
 	case TCP_LINGER2:
 		if (val < 0)
 			tp->linger2 = -1;
@@ -3636,6 +3648,45 @@ static int do_tcp_getsockopt(struct sock
 		}
 		return 0;
 	}
+	/*case TCP_SAVE_SYN_ACK:
+		val = tp->save_syn_ack;
+		break;
+	*/
+	/*case TCP_SAVED_SYN_ACK: {
+		if(get_user(len, optlen)) {
+			return -EFAULT;
+		}
+
+		lock_sock(sk);
+		if(tp->saved_syn_ack) {
+			if(len < tp->saved_syn_ack[0]) {
+				if(put_user(tp->saved_syn_ack[0], optlen)) {
+					release_sock(sk);
+					return -EFAULT;
+				}
+				release_sock(sk);
+				return -EFAULT;
+			}
+			len = tp->saved_syn_ack[0];
+			if(put_user(len, optlen)) {
+				release_sock(sk);
+				return -EFAULT;
+			}
+			if(copy_to_user(optval, tp->saved_syn_ack + 1, len)) {
+				release_sock(sk);
+				return -EFAULT;
+			}
+			tcp_saved_syn_ack_free(tp);
+			release_sock(sk);
+		}
+		else {
+			release_sock(sk);
+			len = 0;
+			if(put_user(len, optlen))
+				return -EFAULT;
+		}
+		return 0;
+	}*/
 #ifdef CONFIG_MMU
 	case TCP_ZEROCOPY_RECEIVE: {
 		struct tcp_zerocopy_receive zc;
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/net/ipv4/tcp_input.c linux-stable/net/ipv4/tcp_input.c
--- linux-5-3-5/net/ipv4/tcp_input.c	2021-11-15 14:40:26.374850073 +0100
+++ linux-stable/net/ipv4/tcp_input.c	2020-07-18 10:57:13.926982159 +0200
@@ -3895,7 +3895,6 @@ void tcp_parse_options(const struct net
 					smc_parse_options(th, opt_rx, ptr,
 							  opsize);
 				break;
-
 			}
 			ptr += opsize-2;
 			length -= opsize;
@@ -5953,7 +5952,8 @@ discard:
 			tcp_drop(sk, skb);
 			return 0;
 		} else {
-			tcp_send_ack(sk);
+			vtl_tcp_send_ack(sk);
+			tcp_call_bpf(sk, 300, 0, NULL);
 		}
 		return -1;
 	}
@@ -6466,6 +6466,28 @@ static void tcp_reqsk_record_syn(const s
 	}
 }
 
+/*static void tcp_reqsk_record_syn_ack(const struct sock *sk, 
+					struct request_sock *req,
+					const struct sk_buff *skb) {
+	if(tcp_sk(sk)->save_syn_ack) {
+		u32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);
+		u32 *copy;
+
+		copy = kmalloc(len + sizeof(u32), GFP_ATOMIC);
+		if (copy) {
+			copy[0] = len;
+			memcpy(&copy[1], skb_network_header(skb), len);
+			req->saved_syn_ack = copy;
+			pr_warning("INPUT: Successfull call into tcp_reqsk_record_syn_ack().\n");
+		}
+		else
+			pr_warning("INPUT: Error in tcp_reqsk_record_syn_ack(): kmalloc() failed.\n");
+	}
+	else {
+		pr_warning("INPUT: Call to tcp_reqsk_record_syn_ack() failed.\n");
+	}
+}*/
+
 int tcp_conn_request(struct request_sock_ops *rsk_ops,
 		     const struct tcp_request_sock_ops *af_ops,
 		     struct sock *sk, struct sk_buff *skb)
@@ -6573,6 +6595,7 @@ int tcp_conn_request(struct request_sock
 		tcp_reqsk_record_syn(sk, req, skb);
 		fastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);
 	}
+
 	if (fastopen_sk) {
 		af_ops->send_synack(fastopen_sk, dst, &fl, req,
 				    &foc, TCP_SYNACK_FASTOPEN);
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/net/ipv4/tcp_ipv4.c linux-stable/net/ipv4/tcp_ipv4.c
--- linux-5-3-5/net/ipv4/tcp_ipv4.c	2021-11-15 14:40:26.374850073 +0100
+++ linux-stable/net/ipv4/tcp_ipv4.c	2020-07-06 09:59:00.647148849 +0200
@@ -1483,6 +1483,8 @@ struct sock *tcp_v4_syn_recv_sock(const
 	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
 	if (likely(*own_req)) {
 		tcp_move_syn(newtp, req);
+		// TODO: Understand the implication of below call
+		//tcp_move_syn_ack(newtp, req);
 		ireq->ireq_opt = NULL;
 	} else {
 		newinet->inet_opt = NULL;
@@ -2108,6 +2110,7 @@ void tcp_v4_destroy_sock(struct sock *sk
 	tcp_free_fastopen_req(tp);
 	tcp_fastopen_destroy_cipher(sk);
 	tcp_saved_syn_free(tp);
+	//tcp_saved_syn_ack_free(tp);
 
 	sk_sockets_allocated_dec(sk);
 }
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/net/ipv4/tcp_output.c linux-stable/net/ipv4/tcp_output.c
--- linux-5-3-5/net/ipv4/tcp_output.c	2021-11-15 14:40:26.374850073 +0100
+++ linux-stable/net/ipv4/tcp_output.c	2020-07-10 22:29:09.728926477 +0200
@@ -46,6 +46,8 @@
 
 #include <trace/events/tcp.h>
 
+static int ack_of_synack = -1;
+
 /* Refresh clocks of a TCP socket,
  * ensuring monotically increasing values.
  */
@@ -452,9 +454,11 @@ struct tcp_out_options {
  * (but it may well be that other scenarios fail similarly).
  */
 static void tcp_options_write(__be32 *ptr, struct tcp_sock *tp,
-			      struct tcp_out_options *opts)
+			      struct tcp_out_options *opts, u32 tcp_packet_type)
 {
 	u16 options = opts->options;	/* mungable copy */
+	int bpf_ret, v_test_flags;
+	struct sock *sk;
 
 	if (unlikely(OPTION_MD5 & options)) {
 		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
@@ -546,6 +550,21 @@ static void tcp_options_write(__be32 *pt
 	}
 
 	smc_options_write(ptr, &options);
+
+	v_test_flags = BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_VTL_OPT_WRITE_FLAG);
+	if(v_test_flags) {
+		sk = (struct sock *)tp;
+
+		bpf_ret = tcp_call_bpf_2arg(sk, 200/* TODO: BPF_SOCK_OPS_VTL_WRITE_OPT_CB*/, 0, tcp_packet_type);
+
+		if(bpf_ret >= 0) {
+			int len = (bpf_ret << 16) >> 24;
+
+			*(int *)ptr = bpf_ret;
+
+			ptr += len;
+		}
+	}
 }
 
 static void smc_set_option(const struct tcp_sock *tp,
@@ -586,8 +605,7 @@ static void smc_set_option_cond(const st
  */
 static unsigned int tcp_syn_options(struct sock *sk, struct sk_buff *skb,
 				struct tcp_out_options *opts,
-				struct tcp_md5sig_key **md5)
-{
+				struct tcp_md5sig_key **md5){
 	struct tcp_sock *tp = tcp_sk(sk);
 	unsigned int remaining = MAX_TCP_OPTION_SPACE;
 	struct tcp_fastopen_request *fastopen = tp->fastopen_req;
@@ -762,7 +780,6 @@ static unsigned int tcp_established_opti
 	return size;
 }
 
-
 /* TCP SMALL QUEUES (TSQ)
  *
  * TSQ goal is to keep small amount of skbs per tcp flow in tx queues (qdisc+dev)
@@ -1023,7 +1040,8 @@ static int __tcp_transmit_skb(struct soc
 	struct tcp_md5sig_key *md5;
 	struct tcphdr *th;
 	u64 prior_wstamp;
-	int err;
+	int err, extended_len = 0;
+	u32 tcp_packet_type;
 
 	BUG_ON(!skb || !tcp_skb_pcount(skb));
 	tp = tcp_sk(sk);
@@ -1055,6 +1073,20 @@ static int __tcp_transmit_skb(struct soc
 	else
 		tcp_options_size = tcp_established_options(sk, skb, &opts,
 							   &md5);
+
+	if(BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_VTL_OPT_WRITE_FLAG)) {
+		
+		// TODO: Translate below comment
+		// Garde fou pour ne pas augmenter la taille à l'aveugle.
+
+		//TODO: replace 100
+		extended_len = tcp_call_bpf_2arg(sk, 100, 0, tcp_options_size);
+
+		if(extended_len > 0 /*&& (tcp_options_size + extended_len<= 40)*/){
+			tcp_options_size += extended_len;
+		}
+	}
+
 	tcp_header_size = tcp_options_size + sizeof(struct tcphdr);
 
 	/* if no packet is in qdisc/device queue, then allow XPS to select
@@ -1107,7 +1139,26 @@ static int __tcp_transmit_skb(struct soc
 		}
 	}
 
-	tcp_options_write((__be32 *)(th + 1), tp, &opts);
+	/* TCP packet type ! */
+	if(th->syn && !th->ack){
+		tcp_packet_type = TCP_SYN;
+	}
+	else if(th->syn && th->ack) { // Should never hapened but just in case.
+		tcp_packet_type = TCP_SYN_ACK; 
+	}
+	else if(!th->syn && th->ack) {
+		if(ack_of_synack == 1) { // This is an ACK of a SYN/ACK
+			tcp_packet_type = TCP_ACK_SYN;
+			ack_of_synack = -1; // Reinit !
+		}
+		else
+			tcp_packet_type = TCP_PURE_ACK;
+	}
+	else {
+		tcp_packet_type = TCP_DATA;
+	}
+
+	tcp_options_write((__be32 *)(th + 1), tp, &opts, tcp_packet_type);
 	skb_shinfo(skb)->gso_type = sk->sk_gso_type;
 	if (likely(!(tcb->tcp_flags & TCPHDR_SYN))) {
 		th->window      = htons(tcp_select_window(sk));
@@ -1577,8 +1628,10 @@ unsigned int tcp_current_mss(struct sock
 	const struct dst_entry *dst = __sk_dst_get(sk);
 	u32 mss_now;
 	unsigned int header_len;
+	unsigned int opt_len;
 	struct tcp_out_options opts;
 	struct tcp_md5sig_key *md5;
+	int extended_len = 0;
 
 	mss_now = tp->mss_cache;
 
@@ -1588,8 +1641,17 @@ unsigned int tcp_current_mss(struct sock
 			mss_now = tcp_sync_mss(sk, mtu);
 	}
 
-	header_len = tcp_established_options(sk, NULL, &opts, &md5) +
-		     sizeof(struct tcphdr);
+	opt_len = tcp_established_options(sk, NULL, &opts, &md5);
+
+	if(BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_VTL_OPT_WRITE_FLAG)) {
+		extended_len = tcp_call_bpf_2arg(sk, 100, 0, opt_len);
+
+		if(extended_len > 0 /*&& (tcp_options_size + extended_len<= 40)*/){
+			opt_len += extended_len;
+		}
+	}
+
+	header_len = opt_len + sizeof(struct tcphdr);
 	/* The mss_cache is sized based on tp->tcp_header_len, which assumes
 	 * some common options. If this is an odd packet (because we have SACK
 	 * blocks etc) then our calculated header_len will be different, and
@@ -1814,7 +1876,6 @@ static int tcp_init_tso_segs(struct sk_b
 	return tso_segs;
 }
 
-
 /* Return true if the Nagle test allows this packet to be
  * sent now.
  */
@@ -3222,6 +3283,28 @@ int tcp_send_synack(struct sock *sk)
 	return tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 }
 
+/*static void tcp_reqsk_record_syn_ack(const struct sock *sk, 
+					struct request_sock *req,
+					const struct sk_buff *skb) {
+	if(tcp_sk(sk)->save_syn_ack) {
+		u32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);
+		u32 *copy;
+
+		copy = kmalloc(len + sizeof(u32), GFP_ATOMIC);
+		if (copy) {
+			copy[0] = len;
+			memcpy(&copy[1], skb_network_header(skb), len);
+			req->saved_syn_ack = copy;
+			pr_warning("Successfull call into tcp_reqsk_record_syn_ack().\n");
+		}
+		else
+			pr_warning("Error in tcp_reqsk_record_syn_ack(): kmalloc() failed.\n");
+	}
+	else {
+		pr_warning("Call to tcp_reqsk_record_syn_ack() failed.\n");
+	}
+}*/
+
 /**
  * tcp_make_synack - Prepare a SYN-ACK.
  * sk: listener socket
@@ -3238,6 +3321,8 @@ struct sk_buff *tcp_make_synack(const st
 {
 	struct inet_request_sock *ireq = inet_rsk(req);
 	const struct tcp_sock *tp = tcp_sk(sk);
+	struct sock *copy_sk;
+	int extended_len, tcp_options_size;
 	struct tcp_md5sig_key *md5 = NULL;
 	struct tcp_out_options opts;
 	struct sk_buff *skb;
@@ -3293,8 +3378,20 @@ struct sk_buff *tcp_make_synack(const st
 	md5 = tcp_rsk(req)->af_specific->req_md5_lookup(sk, req_to_sk(req));
 #endif
 	skb_set_hash(skb, tcp_rsk(req)->txhash, PKT_HASH_TYPE_L4);
-	tcp_header_size = tcp_synack_options(sk, req, mss, skb, &opts, md5,
-					     foc) + sizeof(*th);
+
+	tcp_options_size = tcp_synack_options(sk, req, mss, skb, &opts, md5,
+					     foc);
+
+	if(BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_VTL_OPT_WRITE_FLAG)) {
+		copy_sk = (struct sock *) sk;
+		extended_len = tcp_call_bpf_2arg(copy_sk, 100, 0, tcp_options_size); 
+
+		if(extended_len > 0) {
+			tcp_options_size += extended_len;
+		}
+	}
+
+	tcp_header_size = tcp_options_size + sizeof(*th);
 
 	skb_push(skb, tcp_header_size);
 	skb_reset_transport_header(skb);
@@ -3314,7 +3411,7 @@ struct sk_buff *tcp_make_synack(const st
 
 	/* RFC1323: The window in SYN & SYN/ACK segments is never scaled. */
 	th->window = htons(min(req->rsk_rcv_wnd, 65535U));
-	tcp_options_write((__be32 *)(th + 1), NULL, &opts);
+	tcp_options_write((__be32 *)(th + 1), (struct tcp_sock *)tp, &opts, TCP_SYN_ACK);
 	th->doff = (tcp_header_size >> 2);
 	__TCP_INC_STATS(sock_net(sk), TCP_MIB_OUTSEGS);
 
@@ -3329,6 +3426,9 @@ struct sk_buff *tcp_make_synack(const st
 	skb->skb_mstamp_ns = now;
 	tcp_add_tx_delay(skb, tp);
 
+	//pr_info("Should recorded SYN/ACK; syn=%d, ack=%d", tcp_hdr(skb)->syn, tcp_hdr(skb)->ack);
+	//tcp_reqsk_record_syn_ack(sk, req, skb);
+
 	return skb;
 }
 EXPORT_SYMBOL(tcp_make_synack);
@@ -3691,6 +3791,11 @@ void tcp_send_ack(struct sock *sk)
 	__tcp_send_ack(sk, tcp_sk(sk)->rcv_nxt);
 }
 
+void vtl_tcp_send_ack(struct sock *sk) {
+	ack_of_synack = 1;
+	__tcp_send_ack(sk, tcp_sk(sk)->rcv_nxt);
+}
+
 /* This routine sends a packet with an out of date sequence
  * number. It assumes the other end will try to ack it.
  *
Binary files linux-5-3-5/scripts/asn1_compiler and linux-stable/scripts/asn1_compiler differ
Binary files linux-5-3-5/scripts/extract-cert and linux-stable/scripts/extract-cert differ
Binary files linux-5-3-5/scripts/insert-sys-cert and linux-stable/scripts/insert-sys-cert differ
Binary files linux-5-3-5/scripts/selinux/mdp/mdp and linux-stable/scripts/selinux/mdp/mdp differ
Binary files linux-5-3-5/scripts/sign-file and linux-stable/scripts/sign-file differ
Binary files linux-5-3-5/tools/objtool/objtool and linux-stable/tools/objtool/objtool differ
diff -uprN -X linux-5-3-5/Documentation/dontdiff linux-5-3-5/tools/testing/selftests/bpf/bpf_helpers.h linux-stable/tools/testing/selftests/bpf/bpf_helpers.h
--- linux-5-3-5/tools/testing/selftests/bpf/bpf_helpers.h	2021-11-15 14:40:28.329872144 +0100
+++ linux-stable/tools/testing/selftests/bpf/bpf_helpers.h	2020-01-08 13:26:46.763002703 +0100
@@ -53,6 +53,8 @@ static int (*bpf_get_current_comm)(void
 static unsigned long long (*bpf_perf_event_read)(void *map,
 						 unsigned long long flags) =
 	(void *) BPF_FUNC_perf_event_read;
+static int (*bpf_vtl_nic_tx(void *ctx, int ifindex, int flags)) =
+	(void *) BPF_FUNC_vtl_nic_tx;
 static int (*bpf_clone_redirect)(void *ctx, int ifindex, int flags) =
 	(void *) BPF_FUNC_clone_redirect;
 static int (*bpf_redirect)(int ifindex, int flags) =
